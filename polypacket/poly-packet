#!/usr/bin/python3
"""
An example of a BufferControl in a full screen layout that offers auto
completion.
Important is to make sure that there is a `CompletionsMenu` in the layout,
otherwise the completions won't be visible.
"""
from prompt_toolkit.application import Application
from prompt_toolkit.buffer import Buffer
from prompt_toolkit.completion import WordCompleter
from prompt_toolkit.key_binding import KeyBindings
from prompt_toolkit.widgets import SearchToolbar, TextArea
from prompt_toolkit.layout.containers import (
    Float,
    FloatContainer,
    HSplit,
    Window,
)
from prompt_toolkit.layout.controls import BufferControl, FormattedTextControl
from prompt_toolkit.layout.layout import Layout
from prompt_toolkit.styles import Style
from prompt_toolkit.layout.menus import CompletionsMenu

from polypacket.protocol import *
from polypacket.polyservice import *

import sys
import os
import argparse

args = None
parser = None
PROTOCOL = ''
SERVICE = ''

# The completer.
command_completer = WordCompleter([
    'connect', 'send'], ignore_case=True)

connect_completer = WordCompleter(['serial:','udp:'],ignore_case=True)

packet_completer = ''


outputBuffer = Buffer(multiline=True)

# Style.
style = Style([
    ('output-win', 'bg:#000000 #00ff00'),
    ('input-win', 'bg:#000000 #ffffff'),
    ('line',        '#004400'),
    ('status', 'bg:#004400 #ffffff')
])

def onInputChange(buff):
    global outputBuffer
    global PROTOCOL
    input = buff.text
    if len(input) > 0:
        if input[-1:] == " ":
            word = input.split()[0].strip()
            if word.lower() == 'connect':
                buff.completer = connect_completer

            elif word in PROTOCOL.packetIdx:
                id = PROTOCOL.packetIdx[word]
                packet = PROTOCOL.packets[id]
                fields = []
                for field in packet.fields:
                    fields.append(field.name +":")

                buff.completer = WordCompleter(fields,ignore_case=True )

# The layout
inputBuffer = Buffer(completer=command_completer, complete_while_typing=False, multiline=False, on_text_changed=onInputChange)
#inputBuffer.text = 'SendCmd src: 45, dst: 32, cmd: 4'

outputWin = Window(BufferControl(buffer=outputBuffer,focusable=False), height=20, style='class:output-win')
inputWin = Window(BufferControl(buffer=inputBuffer),style='class:input-win')
body = FloatContainer(
    content=HSplit([
        outputWin,
        Window(height=1, char='-', style='class:line'),
        inputWin,
    ]),
    floats=[
        Float(xcursor=True,
              ycursor=True,
              content=CompletionsMenu(max_height=16, scroll_offset=1))
    ]
)


# Key bindings
kb = KeyBindings()


@kb.add('q')
@kb.add('c-c')
def _(event):
    " Quit application. "
    event.app.exit()

# @kb.add('enter')
# def _(event):
#     global packet_completer
#     new_text =outputBuffer.text + "\n"+ inputBuffer.text
#     outputBuffer.text = new_text
#     inputBuffer.text = '>>> '
#     inputBuffer.completer = packet_completer
#     testService(SERVICE)

def accept(buff):
    global packet_completer
    #new_text =outputBuffer.text + "\n"+ inputBuffer.text
    #outputBuffer.text = new_text
    parseCommand(inputBuffer.text)
    #inputBuffer.text = '>>> '
    inputBuffer.completer = packet_completer


#buff.on_text_changed = onInputChange;
inputBuffer.accept_handler = accept


# The `Application`
application = Application(
    layout=Layout(body),
    key_bindings=kb,
    style=style,
    full_screen=True)

# Initialize the argument parser
def init_args():
    global parser
    parser = argparse.ArgumentParser("Tool to generate code and documentation for PolyPacket protocol")
    parser.add_argument('-i', '--input', type=str, help='input file to parse', default="")
    parser.add_argument('-t', '--test', action='store_true', help='Runs test on protocol', default=False)

def printToConsole( text):
    global outputBuffer
    new_text =outputBuffer.text + "\n"
    new_text+=  text


    outputBuffer.text = new_text

def parseCommand(text):

    words = text.split()

    if words[0].lower() == 'connect':
        SERVICE.addIface(words[1])
        return 0

    packetType = words[0].strip()

    newPacket = SERVICE.newPacket(packetType)

    if len(words) > 1:
        fields = text[len(packetType):].split(',')

        for field in fields:
            subFields = field.split(':')
            fname = subFields[0].strip()
            val = subFields[1].strip()
            newPacket.setField(fname, val)

    SERVICE.interfaces[0].sendPacket(newPacket)

def run():
    global parser
    global args
    global inputBuffer
    global PROTOCOL
    global SERVICE
    global packet_completer

    init_args()
    args= parser.parse_args()

    # The layout.
    #search_field = SearchToolbar()  # For reverse search.
    inputFile = args.input

    if inputFile == "":
        print("No input file specified, use poly-packet -e to create an example file")
        sys.exit()

    if os.path.isfile(inputFile):
        print( "Parsing " + inputFile)
        fileCrc, fileHash = crc(inputFile)

        PROTOCOL = buildProtocol(inputFile)

        SERVICE = PolyService(PROTOCOL)
        SERVICE.print = printToConsole
        if args.test:
            testService(SERVICE)


        PROTOCOL.hash = fileHash
        PROTOCOL.crc = fileCrc


    packetNames = []
    for packet in PROTOCOL.packets:
        packetNames.append(packet.name)

    packetNames.append('connect')

    packet_completer = WordCompleter(packetNames,ignore_case=True)

    inputBuffer.completer = packet_completer

    application.run()

def testService(service):

    service.addIface("")
    newPacket = service.newPacket('Data')
    newPacket.setField('sensorA', 123)
    newPacket.setField('sensorName', "testName")

    #print(newPacket.printJSON())

    test = service.interfaces[0].sendPacket(newPacket)


    service.interfaces[0].feedEncodedBytes(test)

    #exit()

if __name__ == '__main__':
    run()
